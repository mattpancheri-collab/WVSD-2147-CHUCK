# 2026 Robot Code - Mentor Guide

Welcome to the mentor-facing documentation for the 2026 Robot Code! This guide is designed to help you understand the core architectural philosophy of the codebase and effectively guide students as they learn to read, write, and tune code.

---

## üèóÔ∏è Architectural Overview

This codebase is built using WPILib's **Command-Based Framework**. We enforce strict separation of concerns to make the code scalable and easy for students to digest layer by layer.

### 1. Centralized Constants
To prevent overlapping CAN IDs and scattered tuning values, **all mechanism configuration is centralized in `Constants.java`**. 
*   **Why?** Students often copy/paste code and forget to change IDs, leading to "duplicate CAN ID" bugs that are notoriously hard to track down. By keeping them here, it is obvious when an ID is reused.
*   **Tuning values (PIDs, Speeds, Angles)** are also static final fields here. When students need to tune, direct them to this single file rather than digging through subfolders.

### 2. Subsystem Encapsulation
Each subsystem (e.g., `Launcher`, `IntakePivot`) is responsible for **its own hardware and its own telemetry**.
*   We use WPILib's `SysIdRoutine` directly inside the subystems to characterize them individually.
*   We use Phoenix 6's `SignalLogger` and WPILib's `@Logged` annotations to automatically generate data logs without cluttering the periodic loop.

### 3. Command Factories
Complex sequences (like "Deploy Intake, Spin Roller, Feed to Shooter") are built using **Command Factories** located in `src/main/java/frc/robot/commands/`.
*   **Why?** This prevents `RobotContainer.java` from becoming a massive, unreadable file full of inline lambda expressions.
*   Students should use these factories (e.g., `IntakeFactory.deployAndIntakeChainVoltage()`) to compose autonomous routines and button bindings.

---

## üë©‚Äçüè´ Guiding Students

### Where Students Get Stuck
1.  **"My button isn't doing anything."**
    *   *Check:* Did they bind the command in `RobotContainer.java` inside `configureBindings()`?
    *   *Check:* Does the WPILib Command actually finish? Ensure the button binding (e.g. `whileTrue()` vs `onTrue()`) matches the Command type.
2.  **"The motor spins the wrong way."**
    *   *Check:* Have them navigate to the specific Subsystem file and look for the hardware initialization (usually in the constructor). Show them how to invert the `TalonFX` or `SparkMax`.
3.  **"PathPlanner isn't running my command."**
    *   *Check:* In `RobotContainer.java`, inside `registerNamedCommands()`, the string name MUST perfectly match the event marker string in the PathPlanner GUI. If one says `"Shoot"` and the other says `"shoot"`, it will fail silently.

### Safe Tuning Practices
Before giving a motor full PID or Percent control, **always use Voltage control first**.
*   We have set up a "Testing Controller" (Port 2) in `RobotContainer.java` (`testingJoystick`). 
*   This controller uses small, clamped voltage values defined in `Constants.TestingConstants`.
*   Have students use this to verify the motor spins the correct direction and the mechanism moves freely before attempting high-speed testing.

---

## ‚öôÔ∏è Advanced Tuning & Adjustments

### Swerve Drive Characterization (SysId)
The `CommandSwerveDrivetrain` is generated by the Phoenix Tuner X suite. It includes built-in WPILib SysId routines for translation, rotation, and steer characterization.
*   **Where to find it:** `CommandSwerveDrivetrain.java`.
*   **How to run it:** Bind `drivetrain.sysIdQuasistatic()` and `sysIdDynamic()` to buttons in `RobotContainer` and deploy the code to capture logs for analysis in the WPILib SysId tool.

### PathPlanner Autonomous
PathPlanner integration is handled entirely in `CommandSwerveDrivetrain.java`.
*   **Where to adjust Gains:** Open `CommandSwerveDrivetrain.java` and locate the `configurePathPlanner()` method.
*   The `PPHolonomicDriveController` takes two `PIDConstants`:
    *   **Translation PID:** Controls path following accuracy (X/Y).
    *   **Rotation PID:** Controls heading accuracy.
*   *Mentor Tip:* Have students tune the Translation P value first. If the robot overshoots waypoints, decrease P or add D. Ensure the physical robot measurements (Mass, MOI, Wheelbase) in the GUI settings are accurate, as the `RobotConfig` object relies on them.

---

## üìà Code Maintenance

As the season progresses, ensure students do not slowly move logic out of Subsystems and into factory commands. Remind them:
*   **Subsystems** = "How" things happen (the physical hardware).
*   **Commands** = "When" things happen (the sequences).
